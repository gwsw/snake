<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Snake</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>

<script src="../jlib/gfx.js"></script>

<script>

// --------------------------------------------------------------------
// Globals
var _game = null;

var config = {
    upint                  : 1000, // update interval; ms
    wcells                 : 36,
    hcells                 : 20,
    seg_xmargin            : 1,
    seg_ymargin            : 1,
    win_xmargin            : 16,
    win_ymargin            : 16,

    color_bg               : "101010",
    color_food             : "0070f0",
    color_game_over        : "ff2020",
    color_margin           : "c05000",
    color_snake            : "a0a010",
    color_snake_hilite     : "ff0010",
};

// --------------------------------------------------------------------
class CellItem {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }
    draw(gfx, cellw, cellh, color = this.color) {
        const x = config.win_xmargin + cellw * this.x;
        const y = config.win_ymargin + cellh * this.y;
        const xm = config.seg_xmargin;
        const ym = config.seg_ymargin;
        gfx.draw_rect(x + xm, y + ym, cellw - 2*xm, cellh - 2*ym, color);
    }
};

// --------------------------------------------------------------------
class Seg extends CellItem {
    constructor(x, y) {
        super(x, y, config.color_snake);
    }
    draw(gfx, cellw, cellh, hilite) {
        const color = hilite ? config.color_snake_hilite : config.color_snake;
        super.draw(gfx, cellw, cellh, color);
    }
};

// --------------------------------------------------------------------
class Food extends CellItem {
    constructor(x, y) {
        super(x, y, config.color_food);
    }
};

// --------------------------------------------------------------------
class Game {
    constructor(gfx) {
        this.gfx = gfx;
        this.xdelta = +1;
        this.ydelta = 0;
        this.upint = config.upint;
        this.last_update = 0;
        this.hilite_x = -1;
        this.hilite_y = -1;
        this.playing = true;
        this.paused = false;
        const x = Math.floor(config.wcells/2);
        const y = Math.floor(config.hcells/2);
        this.snake = [ new Seg(x+1, y), new Seg(x, y) ];
        this.new_food();
    }
    new_food() {
        let x;
        let y;
        for (;;) {
            x = randu(config.wcells);
            y = randu(config.hcells);
            if (!this.intersects_snake(x, y)) break;
        }
        this.food = new Food(x, y);
    }
    run() {
        if (!this.playing) return;
        if (!this.paused) this.update();
        this.draw();
    }
    update() {
        if (this.last_update + this.upint > now()) return;
        this.update_now();
    }
    update_now() {
        const x = this.snake[0].x + this.xdelta;
        const y = this.snake[0].y + this.ydelta;
        if (x < 0 || x >= config.wcells || y < 0 || y >= config.hcells) {
            this.game_over();
        } else if (this.intersects_snake(x, y)) {
            this.hilite_x = x;
            this.hilite_y = y;
            this.game_over();
        } else {
            this.snake.unshift(new Seg(x, y));
            if (this.food != null && this.intersects_snake(this.food.x, this.food.y)) { // just check head
                this.new_food();
            } else {
                this.snake.pop();
            }
        }
        this.last_update = now();
    }
    game_over() {
        this.playing = false;
        this.draw();
    }
    dims() {
        const d = this.gfx.canvas_dims();
        let cellw = Math.floor((d.w - 2*config.win_xmargin) / config.wcells);
        let cellh = Math.floor((d.h - 2*config.win_ymargin) / config.hcells);
        if (cellw < 2) cellw = 2;
        if (cellh < 2) cellh = 2;
        return { cellw:cellw, cellh:cellh };
    }
    draw() {
        const d = this.dims();
        this.gfx.clear(config.color_bg);
        for (const seg of this.snake) {
            const hilite = (seg.x == this.hilite_x && seg.y == this.hilite_y);
            seg.draw(this.gfx, d.cellw, d.cellh, hilite);
        }
        if (this.food != null) {
            this.food.draw(this.gfx, d.cellw, d.cellh);
        }
        this.draw_margin();
        if (!this.playing)
            this.draw_overlay("GAME OVER");
        else if (this.paused)
            this.draw_overlay("PAUSED");
    }
    draw_margin() {
        const canvas = this.gfx.canvas_dims();
        const cw = canvas.w;
        const ch = canvas.h;
        const d = this.dims();
        const lb = config.win_xmargin;
        const tb = config.win_ymargin;
        const rb = cw - d.cellw * config.wcells;
        const bb = ch - d.cellh * config.hcells;
        this.gfx.draw_rect(0,      0,       cw-rb,  tb,    config.color_margin);
        this.gfx.draw_rect(cw-rb,  0,       rb,     ch-bb, config.color_margin);
        this.gfx.draw_rect(lb,     ch-bb,   cw-lb,  bb,    config.color_margin);
        this.gfx.draw_rect(0,      tb,      lb,     ch-tb, config.color_margin);
    }
    intersects_snake(x, y) {
        for(const seg of this.snake) {
            if (seg.x == x && seg.y == y) return true;
        }
        return false;
    }
    draw_overlay(msg) {
        const d = this.gfx.canvas_dims();
        this.gfx.set_font_size(d.h * .12);
        const m = this.gfx.measure_text(msg);
        this.gfx.draw_text((d.w - m.width) / 2, (d.h - m.height) / 2, msg, config.color_game_over);
    }
    static _event_keydown(e) {
        if (_game != null) _game.event_keystroke(e.key, true);
    }
    static _event_keyup(e) {
        if (_game != null) _game.event_keystroke(e.key, false);
    }
    static _event_mousedown(e) {
        if (_game != null) _game.event_mouse(Game.MOUSE_DOWN, e.offsetX, e.offsetY);
    }
    static _event_mouseup(e) {
        if (_game != null) _game.event_mouse(Game.MOUSE_UP, e.offsetX, e.offsetY);
    }
    static _event_mousemove(e) {
        if (_game != null) _game.event_mouse(Game.MOUSE_MOVE, e.offsetX, e.offsetY);
    }
    set_direction(xdelta, ydelta) {
        this.xdelta = xdelta;
        this.ydelta = ydelta;
        this.update_now();
    }
    event_keystroke(key, down) {
        if (!down) return;
        if (!this.playing) return;
        if (key == 'p' || key == 'P') {
            this.paused = !this.paused;
            this.draw();
            return;
        }
        if (this.paused) return;

        switch (key) {
        case 'ArrowDown':
            this.set_direction(0, +1);
            break;
        case 'ArrowUp':
            this.set_direction(0, -1);
            break;
        case 'ArrowRight':
            this.set_direction(+1, 0);
            break;
        case 'ArrowLeft':
            this.set_direction(-1, 0);
            break;
        case 'G':
            break;
        }
    }
    event_mouse(event, x, y) {
        if (event == Game.MOUSE_DOWN) {
        }
    }
    static MOUSE_DOWN = 0;
    static MOUSE_UP   = 1;
    static MOUSE_MOVE = 2;
}; // class Game

// --------------------------------------------------------------------

function run_game() {
    if (_game != null) _game.run();
    window.requestAnimationFrame(run_game);
}

function canvas_size(name, w, h) {
    const canvas = el(name);
    canvas.width = w;
    canvas.height = h;
    return canvas;
}

function canvas_resize() {
    const s = 20;
    return canvas_size("canvas", window.innerWidth - s, window.innerHeight - s);
}

function main() {
    munge_config();
    const canvas = canvas_resize();
    const gfx = new Graphics(canvas.getContext("2d"), canvas.height*.028);
    _game = new Game(gfx);
    document.addEventListener('keyup', Game._event_keyup);
    document.addEventListener('keydown', Game._event_keydown);
    document.addEventListener('mousedown', Game._event_mousedown);
    document.addEventListener('mouseup', Game._event_mouseup);
    document.addEventListener('mousemove', Game._event_mousemove);
    window.addEventListener('resize', canvas_resize, false);
    run_game();
}

</script>
</body>
</html>
